{"ast":null,"code":"class Bard {\n  static JSON = \"json\";\n  static MD = \"markdown\";\n\n  // ID derived from Cookie\n  SNlM0e;\n\n  // HTTPS Headers\n  #headers;\n\n  // Resolution status of initialization call\n  #initPromise;\n  #bardURL = \"https://bard.google.com\";\n\n  // Wether or not to log events to console\n  #verbose = false;\n\n  // Fetch function\n  #fetch = fetch;\n  constructor(cookie, config) {\n    // Register some settings\n    if (config?.verbose == true) this.#verbose = true;\n    if (config?.fetch) this.#fetch = config.fetch;\n\n    // If a Cookie is provided, initialize\n    if (cookie) {\n      this.#initPromise = this.#init(cookie);\n    } else {\n      throw new Error(\"Please provide a Cookie when initializing Bard.\");\n    }\n    this.cookie = cookie;\n  }\n\n  // You can also choose to initialize manually\n  async #init(cookie) {\n    this.#verbose && console.log(\"🚀 Starting intialization\");\n\n    // Assign headers\n    this.#headers = {\n      Host: \"bard.google.com\",\n      \"X-Same-Domain\": \"1\",\n      \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\",\n      \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n      Origin: this.#bardURL,\n      Referer: this.#bardURL,\n      Cookie: typeof cookie === \"object\" ? Object.entries(cookie).map(_ref => {\n        let [key, val] = _ref;\n        return `${key}=${val};`;\n      }).join(\"\") : \"__Secure-1PSID=\" + cookie\n    };\n    let responseText;\n    // Attempt to retrieve SNlM0e\n    try {\n      this.#verbose && console.log(\"🔒 Authenticating your Google account\");\n      responseText = await this.#fetch(this.#bardURL, {\n        method: \"GET\",\n        headers: this.#headers,\n        credentials: \"include\"\n      }).then(response => response.text());\n    } catch (e) {\n      // Failure to get server\n      throw new Error(\"Could not fetch Google Bard. You may be disconnected from internet: \" + e);\n    }\n    try {\n      const SNlM0e = responseText.match(/SNlM0e\":\"(.*?)\"/)[1];\n      // Assign SNlM0e and return it\n      this.SNlM0e = SNlM0e;\n      this.#verbose && console.log(\"✅ Initialization finished\\n\");\n      return SNlM0e;\n    } catch {\n      throw new Error(\"Could not use your Cookie. Make sure that you copied correctly the Cookie with name __Secure-1PSID exactly. If you are sure your cookie is correct, you may also have reached your rate limit.\");\n    }\n  }\n  async #uploadImage(name, buffer) {\n    this.#verbose && console.log(\"🖼️ Starting image processing\");\n    let size = buffer.byteLength;\n    let formBody = [`${encodeURIComponent(\"File name\")}=${encodeURIComponent([name])}`];\n    try {\n      this.#verbose && console.log(\"💻 Finding Google server destination\");\n      let response = await this.#fetch(\"https://content-push.googleapis.com/upload/\", {\n        method: \"POST\",\n        headers: {\n          \"X-Goog-Upload-Command\": \"start\",\n          \"X-Goog-Upload-Protocol\": \"resumable\",\n          \"X-Goog-Upload-Header-Content-Length\": size,\n          \"X-Tenant-Id\": \"bard-storage\",\n          \"Push-Id\": \"feeds/mcudyrk2a4khkz\"\n        },\n        body: formBody,\n        credentials: \"include\"\n      });\n      const uploadUrl = response.headers.get(\"X-Goog-Upload-URL\");\n      this.#verbose && console.log(\"📤 Sending your image\");\n      response = await this.#fetch(uploadUrl, {\n        method: \"POST\",\n        headers: {\n          \"X-Goog-Upload-Command\": \"upload, finalize\",\n          \"X-Goog-Upload-Offset\": 0,\n          \"X-Tenant-Id\": \"bard-storage\"\n        },\n        body: buffer,\n        credentials: \"include\"\n      });\n      const imageFileLocation = await response.text();\n      this.#verbose && console.log(\"✅ Image finished working\\n\");\n      return imageFileLocation;\n    } catch (e) {\n      throw new Error(\"Could not fetch Google Bard. You may be disconnected from internet: \" + e);\n    }\n  }\n\n  // Query Bard\n  async #query(message, config) {\n    let formatMarkdown = (text, images) => {\n      if (!images) return text;\n      for (let imageData of images) {\n        const formattedTag = `!${imageData.tag}(${imageData.url})`;\n        text = text.replace(new RegExp(`(?!\\\\!)\\\\[${imageData.tag.slice(1, -1)}\\\\]`), formattedTag);\n      }\n      return text;\n    };\n    let {\n      ids,\n      imageBuffer\n    } = config;\n\n    // Wait until after init\n    await this.#initPromise;\n    this.#verbose && console.log(\"🔎 Starting Bard Query\");\n\n    // If user has not run init\n    if (!this.SNlM0e) {\n      throw new Error(\"Please initialize Bard first. If you haven't passed in your Cookie into the class, run Bard.init(cookie).\");\n    }\n    this.#verbose && console.log(\"🏗️ Building Request\");\n    // HTTPS parameters\n    const params = {\n      bl: \"boq_assistant-bard-web-server_20230711.08_p0\",\n      _reqID: ids?._reqID ?? \"0\",\n      rt: \"c\"\n    };\n\n    // If IDs are provided, but doesn't have every one of the expected IDs, error\n    const messageStruct = [[message], null, [null, null, null]];\n    if (imageBuffer) {\n      let imageLocation = await this.#uploadImage(`bard-ai_upload`, imageBuffer);\n      messageStruct[0].push(0, null, [[[imageLocation, 1], \"bard-ai_upload\"]]);\n    }\n    if (ids) {\n      const {\n        conversationID,\n        responseID,\n        choiceID\n      } = ids;\n      messageStruct[2] = [conversationID, responseID, choiceID];\n    }\n\n    // HTTPs data\n    const data = {\n      \"f.req\": JSON.stringify([null, JSON.stringify(messageStruct)]),\n      at: this.SNlM0e\n    };\n\n    // URL that we are submitting to\n    const url = new URL(\"/_/BardChatUi/data/assistant.lamda.BardFrontendService/StreamGenerate\", this.#bardURL);\n\n    // Append parameters to the URL\n    for (const key in params) {\n      url.searchParams.append(key, params[key]);\n    }\n\n    // Encode the data\n    const formBody = Object.entries(data).map(_ref2 => {\n      let [property, value] = _ref2;\n      return `${encodeURIComponent(property)}=${encodeURIComponent(value)}`;\n    }).join(\"&\");\n    this.#verbose && console.log(\"💭 Sending message to Bard\");\n    // Send the fetch request\n    const chatData = await this.#fetch(url.toString(), {\n      method: \"POST\",\n      headers: this.#headers,\n      body: formBody,\n      credentials: \"include\"\n    }).then(response => {\n      return response.text();\n    }).then(text => {\n      return JSON.parse(text.split(\"\\n\")[3])[0][2];\n    }).then(rawData => JSON.parse(rawData));\n    this.#verbose && console.log(\"🧩 Parsing output\");\n    // Get first Bard-recommended answer\n    const answer = chatData[4][0];\n\n    // Text of that answer\n    const text = answer[1][0];\n\n    // Get data about images in that answer\n    const images = answer[4]?.map(x => ({\n      tag: x[2],\n      url: x[3][0][0],\n      info: {\n        raw: x[0][0][0],\n        source: x[1][0][0],\n        alt: x[0][4],\n        website: x[1][1],\n        favicon: x[1][3]\n      }\n    })) ?? [];\n    this.#verbose && console.log(\"✅ All done!\\n\");\n    // Put everything together and return\n    return {\n      content: formatMarkdown(text, images),\n      images: images,\n      ids: {\n        conversationID: chatData[1][0],\n        responseID: chatData[1][1],\n        choiceID: answer[0],\n        _reqID: String(parseInt(ids?._reqID ?? 0) + 100000)\n      }\n    };\n  }\n  async #parseConfig(config) {\n    let result = {\n      useJSON: false,\n      imageBuffer: undefined,\n      // Returns as {extension, filename}\n      ids: undefined\n    };\n\n    // Verify that format is one of the two types\n    if (config?.format) {\n      switch (config.format) {\n        case Bard.JSON:\n          result.useJSON = true;\n          break;\n        case Bard.MD:\n          result.useJSON = false;\n          break;\n        default:\n          throw new Error(\"Format can obly be Bard.JSON for JSON output or Bard.MD for Markdown output.\");\n      }\n    }\n\n    // Verify that the image passed in is either a path to a jpeg, jpg, png, or webp, or that it is a Buffer\n    if (config?.image) {\n      if (config.image instanceof ArrayBuffer) {\n        result.imageBuffer = config.image;\n      } else if (typeof config.image === \"string\" && /\\.(jpeg|jpg|png|webp)$/.test(config.image)) {\n        let fs;\n        try {\n          fs = await import(\"fs\");\n        } catch {\n          throw new Error(\"Loading from an image file path is not supported in a browser environment.\");\n        }\n        result.imageBuffer = fs.readFileSync(config.image).buffer;\n      } else {\n        throw new Error(\"Provide your image as a file path to a .jpeg, .jpg, .png, or .webp, or a Buffer.\");\n      }\n    }\n\n    // Verify that all values in IDs exist\n    if (config?.ids) {\n      if (config.ids.conversationID && config.ids.responseID && config.ids.choiceID && config.ids._reqID) {\n        result.ids = config.ids;\n      } else {\n        throw new Error(\"Please provide the IDs exported exactly as given.\");\n      }\n    }\n    return result;\n  }\n\n  // Ask Bard a question!\n  async ask(message, config) {\n    let {\n      useJSON,\n      imageBuffer,\n      ids\n    } = await this.#parseConfig(config);\n    let response = await this.#query(message, {\n      imageBuffer,\n      ids\n    });\n    return useJSON ? response : response.content;\n  }\n  createChat(ids) {\n    let bard = this;\n    class Chat {\n      ids = ids;\n      async ask(message, config) {\n        let {\n          useJSON,\n          imageBuffer\n        } = await bard.#parseConfig(config);\n        let response = await bard.#query(message, {\n          imageBuffer,\n          ids: this.ids\n        });\n        this.ids = response.ids;\n        return useJSON ? response : response.content;\n      }\n      export() {\n        return this.ids;\n      }\n    }\n    return new Chat();\n  }\n}\nexport default Bard;","map":{"version":3,"names":["Bard","JSON","MD","SNlM0e","headers","initPromise","bardURL","verbose","fetch","constructor","cookie","config","init","Error","#init","console","log","Host","Origin","Referer","Cookie","Object","entries","map","_ref","key","val","join","responseText","method","credentials","then","response","text","e","match","uploadImage","#uploadImage","name","buffer","size","byteLength","formBody","encodeURIComponent","body","uploadUrl","get","imageFileLocation","query","#query","message","formatMarkdown","images","imageData","formattedTag","tag","url","replace","RegExp","slice","ids","imageBuffer","params","bl","_reqID","rt","messageStruct","imageLocation","push","conversationID","responseID","choiceID","data","stringify","at","URL","searchParams","append","_ref2","property","value","chatData","toString","parse","split","rawData","answer","x","info","raw","source","alt","website","favicon","content","String","parseInt","parseConfig","#parseConfig","result","useJSON","undefined","format","image","ArrayBuffer","test","fs","readFileSync","ask","createChat","bard","Chat","export"],"sources":["/Users/darshan.a/Documents/Fraud Guard/fraud-guard/node_modules/bard-ai/index.js"],"sourcesContent":["class Bard {\n    static JSON = \"json\";\n    static MD = \"markdown\";\n\n    // ID derived from Cookie\n    SNlM0e;\n\n    // HTTPS Headers\n    #headers;\n\n    // Resolution status of initialization call\n    #initPromise;\n\n    #bardURL = \"https://bard.google.com\";\n\n    // Wether or not to log events to console\n    #verbose = false;\n\n    // Fetch function\n    #fetch = fetch;\n\n    constructor(cookie, config) {\n        // Register some settings\n        if (config?.verbose == true) this.#verbose = true;\n        if (config?.fetch) this.#fetch = config.fetch;\n\n        // If a Cookie is provided, initialize\n        if (cookie) {\n            this.#initPromise = this.#init(cookie);\n        } else {\n            throw new Error(\"Please provide a Cookie when initializing Bard.\");\n        }\n        this.cookie = cookie;\n    }\n\n    // You can also choose to initialize manually\n    async #init(cookie) {\n        this.#verbose && console.log(\"🚀 Starting intialization\");\n\n        // Assign headers\n        this.#headers = {\n            Host: \"bard.google.com\",\n            \"X-Same-Domain\": \"1\",\n            \"User-Agent\":\n                \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\",\n            \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n            Origin: this.#bardURL,\n            Referer: this.#bardURL,\n            Cookie: (typeof cookie === \"object\") ? (Object.entries(cookie).map(([key, val]) => `${key}=${val};`).join(\"\")) : (\"__Secure-1PSID=\" + cookie),\n        };\n\n        let responseText;\n        // Attempt to retrieve SNlM0e\n        try {\n            this.#verbose &&\n                console.log(\"🔒 Authenticating your Google account\");\n            responseText = await this.#fetch(this.#bardURL, {\n                method: \"GET\",\n                headers: this.#headers,\n                credentials: \"include\",\n            })\n                .then((response) => response.text())\n        } catch (e) {\n            // Failure to get server\n            throw new Error(\n                \"Could not fetch Google Bard. You may be disconnected from internet: \" +\n                e\n            );\n        }\n\n        try {\n            const SNlM0e = responseText.match(/SNlM0e\":\"(.*?)\"/)[1];\n            // Assign SNlM0e and return it\n            this.SNlM0e = SNlM0e;\n            this.#verbose && console.log(\"✅ Initialization finished\\n\");\n            return SNlM0e;\n        } catch {\n            throw new Error(\n                \"Could not use your Cookie. Make sure that you copied correctly the Cookie with name __Secure-1PSID exactly. If you are sure your cookie is correct, you may also have reached your rate limit.\"\n            );\n        }\n    }\n\n    async #uploadImage(name, buffer) {\n        this.#verbose && console.log(\"🖼️ Starting image processing\");\n        let size = buffer.byteLength;\n        let formBody = [\n            `${encodeURIComponent(\"File name\")}=${encodeURIComponent([name])}`,\n        ];\n\n        try {\n            this.#verbose &&\n                console.log(\"💻 Finding Google server destination\");\n            let response = await this.#fetch(\n                \"https://content-push.googleapis.com/upload/\",\n                {\n                    method: \"POST\",\n                    headers: {\n                        \"X-Goog-Upload-Command\": \"start\",\n                        \"X-Goog-Upload-Protocol\": \"resumable\",\n                        \"X-Goog-Upload-Header-Content-Length\": size,\n                        \"X-Tenant-Id\": \"bard-storage\",\n                        \"Push-Id\": \"feeds/mcudyrk2a4khkz\",\n                    },\n                    body: formBody,\n                    credentials: \"include\",\n                }\n            );\n\n            const uploadUrl = response.headers.get(\"X-Goog-Upload-URL\");\n            this.#verbose && console.log(\"📤 Sending your image\");\n            response = await this.#fetch(uploadUrl, {\n                method: \"POST\",\n                headers: {\n                    \"X-Goog-Upload-Command\": \"upload, finalize\",\n                    \"X-Goog-Upload-Offset\": 0,\n                    \"X-Tenant-Id\": \"bard-storage\",\n                },\n                body: buffer,\n                credentials: \"include\",\n            });\n\n            const imageFileLocation = await response.text();\n\n            this.#verbose && console.log(\"✅ Image finished working\\n\");\n            return imageFileLocation;\n        } catch (e) {\n            throw new Error(\n                \"Could not fetch Google Bard. You may be disconnected from internet: \" +\n                e\n            );\n        }\n    }\n\n    // Query Bard\n    async #query(message, config) {\n        let formatMarkdown = (text, images) => {\n            if (!images) return text;\n\n            for (let imageData of images) {\n                const formattedTag = `!${imageData.tag}(${imageData.url})`;\n                text = text.replace(\n                    new RegExp(`(?!\\\\!)\\\\[${imageData.tag.slice(1, -1)}\\\\]`),\n                    formattedTag\n                );\n            }\n\n            return text;\n        }\n\n        let { ids, imageBuffer } = config;\n\n        // Wait until after init\n        await this.#initPromise;\n\n        this.#verbose && console.log(\"🔎 Starting Bard Query\");\n\n        // If user has not run init\n        if (!this.SNlM0e) {\n            throw new Error(\n                \"Please initialize Bard first. If you haven't passed in your Cookie into the class, run Bard.init(cookie).\"\n            );\n        }\n\n        this.#verbose && console.log(\"🏗️ Building Request\");\n        // HTTPS parameters\n        const params = {\n            bl: \"boq_assistant-bard-web-server_20230711.08_p0\",\n            _reqID: ids?._reqID ?? \"0\",\n            rt: \"c\",\n        };\n\n        // If IDs are provided, but doesn't have every one of the expected IDs, error\n        const messageStruct = [\n            [message],\n            null,\n            [null, null, null],\n        ];\n\n        if (imageBuffer) {\n            let imageLocation = await this.#uploadImage(\n                `bard-ai_upload`,\n                imageBuffer\n            );\n            messageStruct[0].push(0, null, [\n                [[imageLocation, 1], \"bard-ai_upload\"],\n            ]);\n        }\n\n        if (ids) {\n            const { conversationID, responseID, choiceID } = ids;\n            messageStruct[2] = [conversationID, responseID, choiceID];\n        }\n\n        // HTTPs data\n        const data = {\n            \"f.req\": JSON.stringify([null, JSON.stringify(messageStruct)]),\n            at: this.SNlM0e,\n        };\n\n        // URL that we are submitting to\n        const url = new URL(\n            \"/_/BardChatUi/data/assistant.lamda.BardFrontendService/StreamGenerate\",\n            this.#bardURL\n        );\n\n        // Append parameters to the URL\n        for (const key in params) {\n            url.searchParams.append(key, params[key]);\n        }\n\n        // Encode the data\n        const formBody = Object.entries(data)\n            .map(\n                ([property, value]) =>\n                    `${encodeURIComponent(property)}=${encodeURIComponent(\n                        value\n                    )}`\n            )\n            .join(\"&\");\n\n        this.#verbose && console.log(\"💭 Sending message to Bard\");\n        // Send the fetch request\n        const chatData = await this.#fetch(url.toString(), {\n            method: \"POST\",\n            headers: this.#headers,\n            body: formBody,\n            credentials: \"include\",\n        })\n            .then((response) => {\n                return response.text();\n            })\n            .then((text) => {\n                return JSON.parse(text.split(\"\\n\")[3])[0][2];\n            })\n            .then((rawData) => JSON.parse(rawData));\n\n        this.#verbose && console.log(\"🧩 Parsing output\");\n        // Get first Bard-recommended answer\n        const answer = chatData[4][0];\n\n        // Text of that answer\n        const text = answer[1][0];\n\n        // Get data about images in that answer\n        const images =\n            answer[4]?.map((x) => ({\n                tag: x[2],\n                url: x[3][0][0],\n                info: {\n                    raw: x[0][0][0],\n                    source: x[1][0][0],\n                    alt: x[0][4],\n                    website: x[1][1],\n                    favicon: x[1][3],\n                },\n            })) ?? [];\n\n        this.#verbose && console.log(\"✅ All done!\\n\");\n        // Put everything together and return\n        return {\n            content: formatMarkdown(text, images),\n            images: images,\n            ids: {\n                conversationID: chatData[1][0],\n                responseID: chatData[1][1],\n                choiceID: answer[0],\n                _reqID: String(parseInt(ids?._reqID ?? 0) + 100000),\n            },\n        };\n    }\n\n    async #parseConfig(config) {\n        let result = {\n            useJSON: false,\n            imageBuffer: undefined, // Returns as {extension, filename}\n            ids: undefined,\n        };\n\n        // Verify that format is one of the two types\n        if (config?.format) {\n            switch (config.format) {\n                case Bard.JSON:\n                    result.useJSON = true;\n                    break;\n                case Bard.MD:\n                    result.useJSON = false;\n                    break;\n                default:\n                    throw new Error(\n                        \"Format can obly be Bard.JSON for JSON output or Bard.MD for Markdown output.\"\n                    );\n            }\n        }\n\n        // Verify that the image passed in is either a path to a jpeg, jpg, png, or webp, or that it is a Buffer\n        if (config?.image) {\n            if (\n                config.image instanceof ArrayBuffer\n            ) {\n                result.imageBuffer = config.image;\n            } else if (\n                typeof config.image === \"string\" &&\n                /\\.(jpeg|jpg|png|webp)$/.test(config.image)\n            ) {\n                let fs;\n\n                try {\n                    fs = await import(\"fs\")\n                } catch {\n                    throw new Error(\n                        \"Loading from an image file path is not supported in a browser environment.\",\n                    );\n                }\n\n                result.imageBuffer = fs.readFileSync(\n                    config.image,\n                ).buffer;\n            } else {\n                throw new Error(\n                    \"Provide your image as a file path to a .jpeg, .jpg, .png, or .webp, or a Buffer.\"\n                );\n            }\n        }\n\n        // Verify that all values in IDs exist\n        if (config?.ids) {\n            if (config.ids.conversationID && config.ids.responseID && config.ids.choiceID && config.ids._reqID) {\n                result.ids = config.ids;\n            } else {\n                throw new Error(\n                    \"Please provide the IDs exported exactly as given.\"\n                );\n            }\n        }\n        return result;\n    }\n\n    // Ask Bard a question!\n    async ask(message, config) {\n        let { useJSON, imageBuffer, ids } = await this.#parseConfig(config);\n        let response = await this.#query(message, { imageBuffer, ids });\n        return useJSON ? response : response.content;\n    }\n\n    createChat(ids) {\n        let bard = this;\n        class Chat {\n            ids = ids;\n\n            async ask(message, config) {\n                let { useJSON, imageBuffer } = await bard.#parseConfig(config);\n                let response = await bard.#query(message, {\n                    imageBuffer,\n                    ids: this.ids,\n                });\n                this.ids = response.ids;\n                return useJSON ? response : response.content;\n            }\n\n            export() {\n                return this.ids;\n            }\n        }\n\n        return new Chat();\n    }\n}\n\nexport default Bard;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}